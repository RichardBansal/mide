// Ionic Starter App

// angular.module is a global place for creating, registering and retrieving Angular modules
// 'starter' is the name of this angular module example (also set in a <body> attribute in index.html)
// the 2nd parameter is an array of 'requires'
// 'starter.services' is found in services.js
// 'starter.controllers' is found in controllers.js
var app = angular.module('mide', ['ionic', 'ui.ace'])

.run(function($ionicPlatform) {
  $ionicPlatform.ready(function() {
    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
    // for form inputs)
    // $locationProvider.html5Mode(true);
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
    }
    if (window.StatusBar) {
      // org.apache.cordova.statusbar required
      StatusBar.styleLightContent();
    }
  });
})

//TODO:This is needed to set to access the proxy url that will then in the ionic.project file redirect it to the correct URL
.constant('ApiEndpoint', {
  url : '/api',
  session: '/session'
})

.config(function($stateProvider, $urlRouterProvider) {
  // Ionic uses AngularUI Router which uses the concept of states
  // Learn more here: https://github.com/angular-ui/ui-router
  // Set up the various states which the app can be in.
  // Each state's controller can be found in controllers.js
  // if none of the above states are matched, use this as the fallback
  //$urlRouterProvider.otherwise('/tab/chats');
  //$urlRouterProvider.otherwise('/signup'); // TODO: Richard testing this route
  //$urlRouterProvider.otherwise('/tab/challenge'); //TODO: Tony testing this route
    $urlRouterProvider.otherwise('welcome');
})
//
////TODO:Can you have more then one? .run

//app.run(function ($rootScope, AuthService, $state) {
//
//  var destinationStateRequiresAuth = function (state) {
//    console.log('destinationStateRequiresAuth','state',state,'state.data',state.data);
//    return state.data && state.data.authenticate;
//  };
//
//  // $stateChangeStart is an event fired
//  // whenever the process of changing a state begins.
//  $rootScope.$on('$stateChangeStart', function (event, toState, toParams) {
//
//    if (!destinationStateRequiresAuth(toState)) {
//      // The destination state does not require authentication
//      // Short circuit with return.
//      return;
//    }
//
//    if (AuthService.isAuthenticated()) {
//      // The user is authenticated.
//      // Short circuit with return.
//      return;
//    }
//
//    //if you have a token, grab the user details, otherwise continue to the login state
//
//    // Cancel navigating to new state.
//    event.preventDefault();
//    //TODO: Fix INFINITE LOOP - the user is coming back as null, so server not responding properly
//    //TODO: Testing Issue: Deleting Local Storage breaks the app, this is a developer issue
//    AuthService.getLoggedInUser()
//        .then(function (user) {
//        // If a user is retrieved, then renavigate to the destination
//        // (the second time, AuthService.isAuthenticated() will work)
//        // otherwise, if no user is logged in, go to "login" state.
//          console.log('user',user, 'toState',toState.name,'toParams',toParams);
//          if (user) {
//            $state.go(toState.name, toParams);
//          } else {
//            $state.go('login');
//          }
//        });
//        //, function(rejected){
//        //  console.log('rejected', rejected);
//        //  $state.go('login');
//        //});
//  });
//});

//.run(function ($rootScope, $state, AuthService, AUTH_EVENTS) {
//  $rootScope.$on('$stateChangeStart', function (event,next, nextParams, fromState) {
//
//    if ('data' in next && 'authenticate' in next.data) {
//      var authenticate = next.data.authenticate;
//      if (!AuthService.isAuthorized(authenticate)) {
//        event.preventDefault();
//        $state.go($state.current, {}, {reload: true});
//        $rootScope.$broadcast(AUTH_EVENTS.notAuthorized);
//      }
//    }
//
//    if (!AuthService.isAuthenticated()) {
//      if (next.name !== 'login') {
//        event.preventDefault();
//        $state.go('login');
//      }
//    }
//  });
//});

.run(function ($rootScope, $state, AuthService, AUTH_EVENTS) {

    var destinationStateRequiresAuth = function (state) {
        //console.log('cl - destinationStateRequiresAuth','state.data',state.data,'state.data.auth',state.data.authenticate);
        return state.data && state.data.authenticate;
    };

    //TODO: Need to make authentication more robust
    //TODO: Currently it is not checking the backend route router.get('/token')
    $rootScope.$on('$stateChangeStart', function (event,toState, toParams) {

        //console.log('user Authenticated', AuthService.isAuthenticated());

        if (!destinationStateRequiresAuth(toState)) {
            // The destination state does not require authentication
            // Short circuit with return.
            return;
        }

        if (AuthService.isAuthenticated()) {
            // The user is authenticated.
            // Short circuit with return.
            return;
        }

        //TODO: Not sure how to proceed here
        //else {
        //    $state.go('login');
        //}


        //if ('data' in toState && 'authenticate' in toState.data) {
        //    var authenticate = toState.data.authenticate;
        //    if (!AuthService.isAuthenciated) {
        //        event.preventDefault();
        //        $state.go($state.current, {}, {reload: true});
        //        $rootScope.$broadcast(AUTH_EVENTS.notAuthorized);
        //    } else if(Authserver.username) {
        //        $state.go(toState.name, toParams);
        //    }
        //}
        //if (!AuthService.isAuthenticated()) {
        //    if (toState.name !== 'login') {
        //        event.preventDefault();
        //        $state.go('login');
        //    }
        //} else {
        //    $state.go(toState.name,toParams);
        //}

        //if (AuthService.isAuthenticated()) {
        //    $state.go(toState.name, toParams);
        //} else {
        $state.go('login'); //if above fails, goto login
        //}
    });
})
app.config(function($stateProvider){
	// Each tab has its own nav history stack:
	$stateProvider.state('tab.account', {
		url: '/account',
	    views: {
	    	'tab-account': {
	    		templateUrl: 'features/account/account.html',
				controller: 'AccountCtrl'
			}
	    }
	});
});

app.controller('AccountCtrl', function($scope) {
	$scope.settings = {
		enableFriends: true
	};
});
app.config(function($stateProvider){
	$stateProvider.state('tab.challenge', {
		url: '/challenge',
		views: {
			'tab-challenge' : {
				templateUrl: 'features/challenge/challenge.html',
				controller: 'ChallengeCtrl'
			}
		},
		resolve : {
			challenge : function(ChallengeFactory, $state){
				return ChallengeFactory.getChallenge().catch(function(err){
					$state.go('tab.account');
				});
			}
		}
	});
});

app.controller('ChallengeCtrl', function($scope, ChallengeFactory, challenge, $state){
	$scope.buttons = {
		submit : 'Submit',
		test : 'Test',
		dismiss : 'Dismiss'
	};

	$scope.challenge = challenge;
	$scope.challengeDesc = JSON.parse(challenge[0].body).description;
	$scope.challengeBody = JSON.parse(challenge[0].body).session.setup;


	$scope.submitChallenge = function(){
		$state.go('tab.challenge-submit');
		ChallengeFactory.submitChallenge().then(function(response){

			return response.data;
		}).catch(function(err){
			console.error(JSON.stringify(err));
		});
	};

	$scope.testChallenge = function(){
		ChallengeFactory.testChallenge().then(function(response){
			return response.data;
		}).catch(function(err){
			console.error(JSON.stringify(err));
		});
	};

});

app.factory('ChallengeFactory', function($http, ApiEndpoint){
	return {
		getChallenge : function(){
			return $http.get(ApiEndpoint.url + '/challenge').then(function(response){
				return response.data;
			});
		},
		submitChallenge : function(){
			return $http.post(ApiEndpoint.url + '/challenge/submit').then(function(response){
				return response.data;
			});
		},
		testChallenge : function(){
			return $http.post(ApiEndpoint.url + '/challenge/test/').then(function(response){
				return response.data;
			});
		}
	};
});

app.config(function($stateProvider, USER_ROLES){
	$stateProvider.state('tab.challenge-submit', {
		url : '/challenge/submit',
		views: {
			'tab-challenge' : {
				templateUrl : 'features/challenge-submit/challenge-submit.html',
				controller : 'ChallengeSubmitCtrl'
			}
		},
		data: {
			authenticate: [USER_ROLES.public]
		}
	});
});

app.controller('ChallengeSubmitCtrl', function($scope){

	$scope.aceLoaded = function(_editor){
		console.log(_editor);
	};

	$scope.aceChanged = function(e){
		console.log(e);
	};

	$scope.txt = '';

	$scope.aceConfig = {
		useWrapMode : true,
		showGutter : true,
		theme: 'monokai',
		mode: 'javascript',
		onLoad: $scope.aceLoaded,
		onChange : $scope.aceChanged
	};
	//text needs to be worked on

	console.log('this is loaded');
});

app.config(function($stateProvider){

  $stateProvider.state('tab.chats', {
      url: '/chats',
      views: {
        'tab-chats': {
          templateUrl: 'features/chats/tab-chats.html',
          controller: 'ChatsCtrl'
        }
      }
    })
    .state('tab.chat-detail', {
      url: '/chats/:chatId',
      views: {
        'tab-chats': {
          templateUrl: 'features/chats/chat-detail.html',
          controller: 'ChatDetailCtrl'
        }
      }
    });
});

app.controller('ChatsCtrl', function($scope, Chats) {
  $scope.chats = Chats.all();
  $scope.remove = function(chat) {
    Chats.remove(chat);
  };
});

app.controller('ChatDetailCtrl', function($scope, $stateParams, Chats) {
  $scope.chat = Chats.get($stateParams.chatId);
});

app.factory('Chats', function() {
  // Might use a resource here that returns a JSON array

  // Some fake testing data
  var chats = [{
    id: 0,
    name: 'Ben Sparrow',
    lastText: 'You on your way?',
    face: 'https://pbs.twimg.com/profile_images/514549811765211136/9SgAuHeY.png'
  }, {
    id: 1,
    name: 'Max Lynx',
    lastText: 'Hey, it\'s not me',
    face: 'https://avatars3.githubusercontent.com/u/11214?v=3&s=460'
  },{
    id: 2,
    name: 'Adam Bradleyson',
    lastText: 'I should buy a boat',
    face: 'https://pbs.twimg.com/profile_images/479090794058379264/84TKj_qa.jpeg'
  }, {
    id: 3,
    name: 'Perry Governor',
    lastText: 'Look at my mukluks!',
    face: 'https://pbs.twimg.com/profile_images/491995398135767040/ie2Z_V6e.jpeg'
  }, {
    id: 4,
    name: 'Mike Harrington',
    lastText: 'This is wicked good ice cream.',
    face: 'https://pbs.twimg.com/profile_images/578237281384841216/R3ae1n61.png'
  }];

  return {
    all: function() {
      return chats;
    },
    remove: function(chat) {
      chats.splice(chats.indexOf(chat), 1);
    },
    get: function(chatId) {
      for (var i = 0; i < chats.length; i++) {
        if (chats[i].id === parseInt(chatId)) {
          return chats[i];
        }
      }
      return null;
    }
  };
});

app.config(function($stateProvider){
	$stateProvider.state('login', {
		url : '/login',
		templateUrl : 'features/login/login.html',
		controller : 'LoginCtrl'
	});
});

app.controller('LoginCtrl', function($scope, $ionicPopup, $state, AuthService){
	//$scope.account = function(){
    //
	//};
	$scope.data = {};
	$scope.error = null;

	$scope.login = function(){
		AuthService
			.login($scope.data)
			.then(function(authenticated){ //TODO:authenticated is what is returned
				console.log('authenticated, tab.challenge-submit');
				$state.go('tab.challenge-submit');
				//TODO: We can set the user name here as well. Used in conjunction with a main ctrl
			})
			.catch(function(err){
				$scope.error = 'Login Invalid';
				console.error(JSON.stringify(err))
				var alertPopup = $ionicPopup.alert({
					title: 'Login failed!',
					template: 'Please check your credentials!'
				});
			});
		//LoginFactory
		//	.postLogin($scope.data)
		//	.then(function(response){
		//		AuthTokenFactory.setToken(response.data.token);
		//		//console.log('goto tab-challenge-submit',response.data.token, response.data.user);
		//		$state.go('tab.challenge-submit');
		//		return response; //TODO: remove if not required, you can just change states instead
		//	})
		//	.catch(function(err){
		//		$scope.error = 'Login Invalid';
		//		console.error(JSON.stringify(err));
		//	});
	};
});

//app.factory('LoginFactory',function($http,ApiEndpoint){
//	return{
//		postLogin: function(userdata){
//			console.log('postLogin',JSON.stringify(userdata));
//			return $http.post(ApiEndpoint.url+"/user/login", userdata);
//		}
//	};
//});

//app.controller('LoginCtrl', function ($scope, AuthService, $state) {
//
//	$scope.login = {};
//	$scope.error = null;
//
//	$scope.sendLogin = function (loginInfo) {
//
//		$scope.error = null;
//
//		AuthService.login(loginInfo).then(function () {
//			$state.go('home');
//		}).catch(function () {
//			$scope.error = 'Invalid login credentials.';
//		});
//
//	};
//
//});


app.config(function($stateProvider){
    $stateProvider.state('signup',{
        url:"/signup",
        templateUrl: "features/signup/signup.html",
        controller: 'SignUpCtrl'
    });
});

app.controller('SignUpCtrl',function($http, $scope, $state, SignUpFactory, AuthService){
    $scope.data = {};
    $scope.error = null;

    $scope.signup = function(){
        SignUpFactory //TODO: convert to use Auth Service instead
            .postSignup($scope.data)
            .then(AuthService.signedUp)
            .then(function(response){
                console.log('goto tab-challenge-submit',JSON.stringify(response));
                //$http.get(ApiEndpoint.url+"/");
                //INFO: Session is stored as a cookie on the browser
                //TODO: Add route display session data
            })
            //store data in session
            //$state.go('tab.challenge-submit'); //TODO: Add Route back, removed for testing
            .catch(function(err){
            $scope.error = 'Login Invalid';
            console.error(JSON.stringify(err));
        });
    };

});

//TODO: NEXT How to check for session data stored, or if it is being sent back, somehow?

app.factory('SignUpFactory',function($http, ApiEndpoint){
    return{
        postSignup: function(userdata){
            console.log('postSignup',JSON.stringify(userdata));
            return $http.post(ApiEndpoint.url+"/user/signup", userdata);
        }
    };
});

//TODO: Form Validation

//NEXT: Sending data to the back-end and setting up routes
//Mongoose

app.config(function($stateProvider){
	$stateProvider.state('welcome', {
		url : '/welcome',
		templateUrl : 'features/welcome/welcome.html',
		controller : 'WelcomeCtrl'
	});
});

app.controller('WelcomeCtrl', function($scope, $state, AuthTokenFactory){
	//TODO: Splash page while you load resources (possible idea)
	$scope.login = function(){
		$state.go('login');
	};
	$scope.signup = function(){
		$state.go('signup');
	};

	var token = AuthTokenFactory.getToken()
	if (token) {
		console.log(token)
		$state.go('tab.challenge-submit');
	} else {
		$state.go('login');
	}
	//});
});
//token is sent on every http request
app.factory('AuthInterceptor',function AuthInterceptor(AUTH_EVENTS,$rootScope,$q,AuthTokenFactory){

    var statusDict = {
        401: AUTH_EVENTS.notAuthenticated,
        403: AUTH_EVENTS.notAuthorized
    };

    return {
        request: addToken,
        responseError: function (response) {
            $rootScope.$broadcast(statusDict[response.status], response);
            return $q.reject(response);
        }
    };

    function addToken(config){
        var token = AuthTokenFactory.getToken();
        if(token){
            config.headers = config.headers || {};
            config.headers.Authorization = 'Bearer ' + token;
        }
        return config;
    }
}); //skipped Auth Interceptors given TODO: You could apply the approach in
//http://devdactic.com/user-auth-angularjs-ionic/

app.config(function($httpProvider){
    $httpProvider.interceptors.push('AuthInterceptor');
});

app.constant('AUTH_EVENTS', {
        notAuthenticated: 'auth-not-authenticated',
        notAuthorized: 'auth-not-authorized'
});

app.constant('USER_ROLES', {
        //admin: 'admin_role',
        public: 'public_role'
});

app.factory('AuthTokenFactory',function($window){
    var store = $window.localStorage;
    var key = 'auth-token';

    return {
        getToken: getToken,
        setToken: setToken
    };

    function getToken(){
        return store.getItem(key);
    }

    //TODO: Create log-out function, were if token is not defined, remove token
    function setToken(token){
        if(token){
            store.setItem(key,token);
        } else {
            store.removeItem(key);
        }
    }
});

app.service('AuthService',function($q,$http,USER_ROLES,AuthTokenFactory,ApiEndpoint,$rootScope){
    //var LOCAL_TOKEN_KEY = 'auth-token';
    var username = '';
    var isAuthenticated = false;
    var authToken;


    function loadUserCredentials() {
        //var token = window.localStorage.getItem(LOCAL_TOKEN_KEY);
        var token = AuthTokenFactory.getToken();
        if (token) {
            useCredentials(token);
        }
    }

    function storeUserCredentials(token) {
        AuthTokenFactory.setToken(token);
        useCredentials(token);
    }

    function useCredentials(token) {
        console.log('useCredentials token',token);
        username = token.user; //TODO: check this
        isAuthenticated = true;
        authToken = token.token; //TODO: check this

        // Set the token as header for your requests!
        //$http.defaults.headers.common['X-Auth-Token'] = token; //TODO
    }

    function destroyUserCredentials() {
        authToken = undefined;
        username = '';
        isAuthenticated = false;
        //$http.defaults.headers.common['X-Auth-Token'] = undefined;
        //window.localStorage.removeItem(LOCAL_TOKEN_KEY);
        AuthTokenFactory.setToken(); //empty clears the token
    }

    var logout = function(){
        destroyUserCredentials();
    };

    //var login = function()
    var login = function(userdata){
        console.log('postLogin',JSON.stringify(userdata));
        return $q(function(resolve,reject){
            $http.post(ApiEndpoint.url+"/user/login", userdata)
                .then(function(response){
                    AuthTokenFactory.setToken(response.data.token); //storeUserCredentials
                    isAuthenticated = true;
                    resolve(response); //TODO: sent to authenticated
                });
        });
    };

    loadUserCredentials();

    var isAuthorized = function(authenticated) {
        if (!angular.isArray(authenticated)) {
            authenticated = [authenticated];
        }
        return (isAuthenticated && authenticated.indexOf(USER_ROLES.public) !== -1);
    };
    
    //TODO: Need to fix getLoggedInUser
    //var getLoggedInUser = function () {
    //    console.log('getLoggedInUser called')
    //    // If an authenticated session exists, we
    //    // return the user attached to that session
    //    // with a promise. This ensures that we can
    //    // always interface with this method asynchronously.
    //
    //    //TODO: In what case will the below code run? It will work, but not clear of the use
    //    if (isAuthenticated) {
    //        return $q.when(AuthTokenFactory.getToken());
    //    }
    //
    //    // Make request GET /session.
    //    // If it returns a user, call onSuccessfulLogin with the response.
    //    // If it returns a 401 response, we catch it and instead resolve to null.
    //
    //    //if(AuthTokenFactory.getToken()){
    //    //    return $http.get(ApiEndpoint.url+'/user/token')
    //    //        .then(function(response){
    //    //            console.log('ApiEndpoint.url /user/token response',response);
    //    //            var data = response.data.user
    //    //            //TODO:$rootScope.$broadcast(AUTH_EVENTS.loginSuccess);
    //    //            return data; //user is being returned
    //    //        }).catch(function () {
    //    //            console.log('getLoggedInUser returned null');
    //    //            return null;
    //    //        });
    //    //} else {
    //    //    return $q.reject({data: 'no auth token exists'});
    //    //}
    //    return $http.get(ApiEndpoint.url + '/user/token')
    //        .then(onSuccessfulLogin)
    //        .catch(function(){return null});
    //};
    //
    //function onSuccessfulLogin(response) {
    //    var data = response.data;
    //    console.log(response.data);
    //    //Session.create(data.id, data.user);
    //    AuthTokenFactory.setToken(response.data.token)
    //    //$rootScope.$broadcast(AUTH_EVENTS.loginSuccess);
    //    return data.user;
    //}

    return {
        login: login,
        logout: logout,
        isAuthenticated: function() {
            console.log('AuthService.isAuthenticated()');
            return isAuthenticated;
        },
        username: function(){return username;},
        //getLoggedInUser: getLoggedInUser,
        isAuthorized: isAuthorized
    }

});

//TODO: Did not complete main ctrl 'AppCtrl for handling events' as per http://devdactic.com/user-auth-angularjs-ionic/
app.config(function($stateProvider){

  	// setup an abstract state for the tabs directive
    $stateProvider.state('tab', {
	    url: "/tab",
	    abstract: true,
	    templateUrl: "features/common/tabs/tabs.html"
	});
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyIsImFjY291bnQvYWNjb3VudC5qcyIsImNoYWxsZW5nZS9jaGFsbGVuZ2UuanMiLCJjaGFsbGVuZ2UtY29tcGlsZS9jaGFsbGVuZ2UtY29tcGlsZS5qcyIsImNoYWxsZW5nZS1zdWJtaXQvY2hhbGxlbmdlLXN1Ym1pdC5qcyIsImNoYWxsZW5nZS12aWV3L2NoYWxsZW5nZS12aWV3LmpzIiwiY2hhdHMvY2hhdHMuanMiLCJsb2dpbi9sb2dpbi5qcyIsInNpZ251cC9zaWdudXAuanMiLCJ3ZWxjb21lL3dlbGNvbWUuanMiLCJjb21tb24vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24uanMiLCJjb21tb24vdGFicy90YWJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckVBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdENBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW9uaWMgU3RhcnRlciBBcHBcblxuLy8gYW5ndWxhci5tb2R1bGUgaXMgYSBnbG9iYWwgcGxhY2UgZm9yIGNyZWF0aW5nLCByZWdpc3RlcmluZyBhbmQgcmV0cmlldmluZyBBbmd1bGFyIG1vZHVsZXNcbi8vICdzdGFydGVyJyBpcyB0aGUgbmFtZSBvZiB0aGlzIGFuZ3VsYXIgbW9kdWxlIGV4YW1wbGUgKGFsc28gc2V0IGluIGEgPGJvZHk+IGF0dHJpYnV0ZSBpbiBpbmRleC5odG1sKVxuLy8gdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2YgJ3JlcXVpcmVzJ1xuLy8gJ3N0YXJ0ZXIuc2VydmljZXMnIGlzIGZvdW5kIGluIHNlcnZpY2VzLmpzXG4vLyAnc3RhcnRlci5jb250cm9sbGVycycgaXMgZm91bmQgaW4gY29udHJvbGxlcnMuanNcbnZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnbWlkZScsIFsnaW9uaWMnLCAndWkuYWNlJ10pXG5cbi5ydW4oZnVuY3Rpb24oJGlvbmljUGxhdGZvcm0pIHtcbiAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgLy8gSGlkZSB0aGUgYWNjZXNzb3J5IGJhciBieSBkZWZhdWx0IChyZW1vdmUgdGhpcyB0byBzaG93IHRoZSBhY2Nlc3NvcnkgYmFyIGFib3ZlIHRoZSBrZXlib2FyZFxuICAgIC8vIGZvciBmb3JtIGlucHV0cylcbiAgICAvLyAkbG9jYXRpb25Qcm92aWRlci5odG1sNU1vZGUodHJ1ZSk7XG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMgJiYgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCkge1xuICAgICAgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmhpZGVLZXlib2FyZEFjY2Vzc29yeUJhcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TdGF0dXNCYXIpIHtcbiAgICAgIC8vIG9yZy5hcGFjaGUuY29yZG92YS5zdGF0dXNiYXIgcmVxdWlyZWRcbiAgICAgIFN0YXR1c0Jhci5zdHlsZUxpZ2h0Q29udGVudCgpO1xuICAgIH1cbiAgfSk7XG59KVxuXG4vL1RPRE86VGhpcyBpcyBuZWVkZWQgdG8gc2V0IHRvIGFjY2VzcyB0aGUgcHJveHkgdXJsIHRoYXQgd2lsbCB0aGVuIGluIHRoZSBpb25pYy5wcm9qZWN0IGZpbGUgcmVkaXJlY3QgaXQgdG8gdGhlIGNvcnJlY3QgVVJMXG4uY29uc3RhbnQoJ0FwaUVuZHBvaW50Jywge1xuICB1cmwgOiAnL2FwaScsXG4gIHNlc3Npb246ICcvc2Vzc2lvbidcbn0pXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAvLyBJb25pYyB1c2VzIEFuZ3VsYXJVSSBSb3V0ZXIgd2hpY2ggdXNlcyB0aGUgY29uY2VwdCBvZiBzdGF0ZXNcbiAgLy8gTGVhcm4gbW9yZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXJcbiAgLy8gU2V0IHVwIHRoZSB2YXJpb3VzIHN0YXRlcyB3aGljaCB0aGUgYXBwIGNhbiBiZSBpbi5cbiAgLy8gRWFjaCBzdGF0ZSdzIGNvbnRyb2xsZXIgY2FuIGJlIGZvdW5kIGluIGNvbnRyb2xsZXJzLmpzXG4gIC8vIGlmIG5vbmUgb2YgdGhlIGFib3ZlIHN0YXRlcyBhcmUgbWF0Y2hlZCwgdXNlIHRoaXMgYXMgdGhlIGZhbGxiYWNrXG4gIC8vJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL3RhYi9jaGF0cycpO1xuICAvLyR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy9zaWdudXAnKTsgLy8gVE9ETzogUmljaGFyZCB0ZXN0aW5nIHRoaXMgcm91dGVcbiAgLy8kdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKCcvdGFiL2NoYWxsZW5nZScpOyAvL1RPRE86IFRvbnkgdGVzdGluZyB0aGlzIHJvdXRlXG4gICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnd2VsY29tZScpO1xufSlcbi8vXG4vLy8vVE9ETzpDYW4geW91IGhhdmUgbW9yZSB0aGVuIG9uZT8gLnJ1blxuXG4vL2FwcC5ydW4oZnVuY3Rpb24gKCRyb290U2NvcGUsIEF1dGhTZXJ2aWNlLCAkc3RhdGUpIHtcbi8vXG4vLyAgdmFyIGRlc3RpbmF0aW9uU3RhdGVSZXF1aXJlc0F1dGggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbi8vICAgIGNvbnNvbGUubG9nKCdkZXN0aW5hdGlvblN0YXRlUmVxdWlyZXNBdXRoJywnc3RhdGUnLHN0YXRlLCdzdGF0ZS5kYXRhJyxzdGF0ZS5kYXRhKTtcbi8vICAgIHJldHVybiBzdGF0ZS5kYXRhICYmIHN0YXRlLmRhdGEuYXV0aGVudGljYXRlO1xuLy8gIH07XG4vL1xuLy8gIC8vICRzdGF0ZUNoYW5nZVN0YXJ0IGlzIGFuIGV2ZW50IGZpcmVkXG4vLyAgLy8gd2hlbmV2ZXIgdGhlIHByb2Nlc3Mgb2YgY2hhbmdpbmcgYSBzdGF0ZSBiZWdpbnMuXG4vLyAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50LCB0b1N0YXRlLCB0b1BhcmFtcykge1xuLy9cbi8vICAgIGlmICghZGVzdGluYXRpb25TdGF0ZVJlcXVpcmVzQXV0aCh0b1N0YXRlKSkge1xuLy8gICAgICAvLyBUaGUgZGVzdGluYXRpb24gc3RhdGUgZG9lcyBub3QgcmVxdWlyZSBhdXRoZW50aWNhdGlvblxuLy8gICAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggcmV0dXJuLlxuLy8gICAgICByZXR1cm47XG4vLyAgICB9XG4vL1xuLy8gICAgaWYgKEF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4vLyAgICAgIC8vIFRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQuXG4vLyAgICAgIC8vIFNob3J0IGNpcmN1aXQgd2l0aCByZXR1cm4uXG4vLyAgICAgIHJldHVybjtcbi8vICAgIH1cbi8vXG4vLyAgICAvL2lmIHlvdSBoYXZlIGEgdG9rZW4sIGdyYWIgdGhlIHVzZXIgZGV0YWlscywgb3RoZXJ3aXNlIGNvbnRpbnVlIHRvIHRoZSBsb2dpbiBzdGF0ZVxuLy9cbi8vICAgIC8vIENhbmNlbCBuYXZpZ2F0aW5nIHRvIG5ldyBzdGF0ZS5cbi8vICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4vLyAgICAvL1RPRE86IEZpeCBJTkZJTklURSBMT09QIC0gdGhlIHVzZXIgaXMgY29taW5nIGJhY2sgYXMgbnVsbCwgc28gc2VydmVyIG5vdCByZXNwb25kaW5nIHByb3Blcmx5XG4vLyAgICAvL1RPRE86IFRlc3RpbmcgSXNzdWU6IERlbGV0aW5nIExvY2FsIFN0b3JhZ2UgYnJlYWtzIHRoZSBhcHAsIHRoaXMgaXMgYSBkZXZlbG9wZXIgaXNzdWVcbi8vICAgIEF1dGhTZXJ2aWNlLmdldExvZ2dlZEluVXNlcigpXG4vLyAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbi8vICAgICAgICAvLyBJZiBhIHVzZXIgaXMgcmV0cmlldmVkLCB0aGVuIHJlbmF2aWdhdGUgdG8gdGhlIGRlc3RpbmF0aW9uXG4vLyAgICAgICAgLy8gKHRoZSBzZWNvbmQgdGltZSwgQXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkgd2lsbCB3b3JrKVxuLy8gICAgICAgIC8vIG90aGVyd2lzZSwgaWYgbm8gdXNlciBpcyBsb2dnZWQgaW4sIGdvIHRvIFwibG9naW5cIiBzdGF0ZS5cbi8vICAgICAgICAgIGNvbnNvbGUubG9nKCd1c2VyJyx1c2VyLCAndG9TdGF0ZScsdG9TdGF0ZS5uYW1lLCd0b1BhcmFtcycsdG9QYXJhbXMpO1xuLy8gICAgICAgICAgaWYgKHVzZXIpIHtcbi8vICAgICAgICAgICAgJHN0YXRlLmdvKHRvU3RhdGUubmFtZSwgdG9QYXJhbXMpO1xuLy8gICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgJHN0YXRlLmdvKCdsb2dpbicpO1xuLy8gICAgICAgICAgfVxuLy8gICAgICAgIH0pO1xuLy8gICAgICAgIC8vLCBmdW5jdGlvbihyZWplY3RlZCl7XG4vLyAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdyZWplY3RlZCcsIHJlamVjdGVkKTtcbi8vICAgICAgICAvLyAgJHN0YXRlLmdvKCdsb2dpbicpO1xuLy8gICAgICAgIC8vfSk7XG4vLyAgfSk7XG4vL30pO1xuXG4vLy5ydW4oZnVuY3Rpb24gKCRyb290U2NvcGUsICRzdGF0ZSwgQXV0aFNlcnZpY2UsIEFVVEhfRVZFTlRTKSB7XG4vLyAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50LG5leHQsIG5leHRQYXJhbXMsIGZyb21TdGF0ZSkge1xuLy9cbi8vICAgIGlmICgnZGF0YScgaW4gbmV4dCAmJiAnYXV0aGVudGljYXRlJyBpbiBuZXh0LmRhdGEpIHtcbi8vICAgICAgdmFyIGF1dGhlbnRpY2F0ZSA9IG5leHQuZGF0YS5hdXRoZW50aWNhdGU7XG4vLyAgICAgIGlmICghQXV0aFNlcnZpY2UuaXNBdXRob3JpemVkKGF1dGhlbnRpY2F0ZSkpIHtcbi8vICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuLy8gICAgICAgICRzdGF0ZS5nbygkc3RhdGUuY3VycmVudCwge30sIHtyZWxvYWQ6IHRydWV9KTtcbi8vICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoQVVUSF9FVkVOVFMubm90QXV0aG9yaXplZCk7XG4vLyAgICAgIH1cbi8vICAgIH1cbi8vXG4vLyAgICBpZiAoIUF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4vLyAgICAgIGlmIChuZXh0Lm5hbWUgIT09ICdsb2dpbicpIHtcbi8vICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuLy8gICAgICAgICRzdGF0ZS5nbygnbG9naW4nKTtcbi8vICAgICAgfVxuLy8gICAgfVxuLy8gIH0pO1xuLy99KTtcblxuLnJ1bihmdW5jdGlvbiAoJHJvb3RTY29wZSwgJHN0YXRlLCBBdXRoU2VydmljZSwgQVVUSF9FVkVOVFMpIHtcblxuICAgIHZhciBkZXN0aW5hdGlvblN0YXRlUmVxdWlyZXNBdXRoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NsIC0gZGVzdGluYXRpb25TdGF0ZVJlcXVpcmVzQXV0aCcsJ3N0YXRlLmRhdGEnLHN0YXRlLmRhdGEsJ3N0YXRlLmRhdGEuYXV0aCcsc3RhdGUuZGF0YS5hdXRoZW50aWNhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGUuZGF0YSAmJiBzdGF0ZS5kYXRhLmF1dGhlbnRpY2F0ZTtcbiAgICB9O1xuXG4gICAgLy9UT0RPOiBOZWVkIHRvIG1ha2UgYXV0aGVudGljYXRpb24gbW9yZSByb2J1c3RcbiAgICAvL1RPRE86IEN1cnJlbnRseSBpdCBpcyBub3QgY2hlY2tpbmcgdGhlIGJhY2tlbmQgcm91dGUgcm91dGVyLmdldCgnL3Rva2VuJylcbiAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQsdG9TdGF0ZSwgdG9QYXJhbXMpIHtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCd1c2VyIEF1dGhlbnRpY2F0ZWQnLCBBdXRoU2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKSk7XG5cbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvblN0YXRlUmVxdWlyZXNBdXRoKHRvU3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBUaGUgZGVzdGluYXRpb24gc3RhdGUgZG9lcyBub3QgcmVxdWlyZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgLy8gU2hvcnQgY2lyY3VpdCB3aXRoIHJldHVybi5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBdXRoU2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgaXMgYXV0aGVudGljYXRlZC5cbiAgICAgICAgICAgIC8vIFNob3J0IGNpcmN1aXQgd2l0aCByZXR1cm4uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL1RPRE86IE5vdCBzdXJlIGhvdyB0byBwcm9jZWVkIGhlcmVcbiAgICAgICAgLy9lbHNlIHtcbiAgICAgICAgLy8gICAgJHN0YXRlLmdvKCdsb2dpbicpO1xuICAgICAgICAvL31cblxuXG4gICAgICAgIC8vaWYgKCdkYXRhJyBpbiB0b1N0YXRlICYmICdhdXRoZW50aWNhdGUnIGluIHRvU3RhdGUuZGF0YSkge1xuICAgICAgICAvLyAgICB2YXIgYXV0aGVudGljYXRlID0gdG9TdGF0ZS5kYXRhLmF1dGhlbnRpY2F0ZTtcbiAgICAgICAgLy8gICAgaWYgKCFBdXRoU2VydmljZS5pc0F1dGhlbmNpYXRlZCkge1xuICAgICAgICAvLyAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gICAgICAgICRzdGF0ZS5nbygkc3RhdGUuY3VycmVudCwge30sIHtyZWxvYWQ6IHRydWV9KTtcbiAgICAgICAgLy8gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChBVVRIX0VWRU5UUy5ub3RBdXRob3JpemVkKTtcbiAgICAgICAgLy8gICAgfSBlbHNlIGlmKEF1dGhzZXJ2ZXIudXNlcm5hbWUpIHtcbiAgICAgICAgLy8gICAgICAgICRzdGF0ZS5nbyh0b1N0YXRlLm5hbWUsIHRvUGFyYW1zKTtcbiAgICAgICAgLy8gICAgfVxuICAgICAgICAvL31cbiAgICAgICAgLy9pZiAoIUF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgIC8vICAgIGlmICh0b1N0YXRlLm5hbWUgIT09ICdsb2dpbicpIHtcbiAgICAgICAgLy8gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vICAgICAgICAkc3RhdGUuZ28oJ2xvZ2luJyk7XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy99IGVsc2Uge1xuICAgICAgICAvLyAgICAkc3RhdGUuZ28odG9TdGF0ZS5uYW1lLHRvUGFyYW1zKTtcbiAgICAgICAgLy99XG5cbiAgICAgICAgLy9pZiAoQXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgICAgLy8gICAgJHN0YXRlLmdvKHRvU3RhdGUubmFtZSwgdG9QYXJhbXMpO1xuICAgICAgICAvL30gZWxzZSB7XG4gICAgICAgICRzdGF0ZS5nbygnbG9naW4nKTsgLy9pZiBhYm92ZSBmYWlscywgZ290byBsb2dpblxuICAgICAgICAvL31cbiAgICB9KTtcbn0pIiwiYXBwLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcil7XG5cdC8vIEVhY2ggdGFiIGhhcyBpdHMgb3duIG5hdiBoaXN0b3J5IHN0YWNrOlxuXHQkc3RhdGVQcm92aWRlci5zdGF0ZSgndGFiLmFjY291bnQnLCB7XG5cdFx0dXJsOiAnL2FjY291bnQnLFxuXHQgICAgdmlld3M6IHtcblx0ICAgIFx0J3RhYi1hY2NvdW50Jzoge1xuXHQgICAgXHRcdHRlbXBsYXRlVXJsOiAnZmVhdHVyZXMvYWNjb3VudC9hY2NvdW50Lmh0bWwnLFxuXHRcdFx0XHRjb250cm9sbGVyOiAnQWNjb3VudEN0cmwnXG5cdFx0XHR9XG5cdCAgICB9XG5cdH0pO1xufSk7XG5cbmFwcC5jb250cm9sbGVyKCdBY2NvdW50Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSkge1xuXHQkc2NvcGUuc2V0dGluZ3MgPSB7XG5cdFx0ZW5hYmxlRnJpZW5kczogdHJ1ZVxuXHR9O1xufSk7IiwiYXBwLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlcil7XG5cdCRzdGF0ZVByb3ZpZGVyLnN0YXRlKCd0YWIuY2hhbGxlbmdlJywge1xuXHRcdHVybDogJy9jaGFsbGVuZ2UnLFxuXHRcdHZpZXdzOiB7XG5cdFx0XHQndGFiLWNoYWxsZW5nZScgOiB7XG5cdFx0XHRcdHRlbXBsYXRlVXJsOiAnZmVhdHVyZXMvY2hhbGxlbmdlL2NoYWxsZW5nZS5odG1sJyxcblx0XHRcdFx0Y29udHJvbGxlcjogJ0NoYWxsZW5nZUN0cmwnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXNvbHZlIDoge1xuXHRcdFx0Y2hhbGxlbmdlIDogZnVuY3Rpb24oQ2hhbGxlbmdlRmFjdG9yeSwgJHN0YXRlKXtcblx0XHRcdFx0cmV0dXJuIENoYWxsZW5nZUZhY3RvcnkuZ2V0Q2hhbGxlbmdlKCkuY2F0Y2goZnVuY3Rpb24oZXJyKXtcblx0XHRcdFx0XHQkc3RhdGUuZ28oJ3RhYi5hY2NvdW50Jyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ0NoYWxsZW5nZUN0cmwnLCBmdW5jdGlvbigkc2NvcGUsIENoYWxsZW5nZUZhY3RvcnksIGNoYWxsZW5nZSwgJHN0YXRlKXtcblx0JHNjb3BlLmJ1dHRvbnMgPSB7XG5cdFx0c3VibWl0IDogJ1N1Ym1pdCcsXG5cdFx0dGVzdCA6ICdUZXN0Jyxcblx0XHRkaXNtaXNzIDogJ0Rpc21pc3MnXG5cdH07XG5cblx0JHNjb3BlLmNoYWxsZW5nZSA9IGNoYWxsZW5nZTtcblx0JHNjb3BlLmNoYWxsZW5nZURlc2MgPSBKU09OLnBhcnNlKGNoYWxsZW5nZVswXS5ib2R5KS5kZXNjcmlwdGlvbjtcblx0JHNjb3BlLmNoYWxsZW5nZUJvZHkgPSBKU09OLnBhcnNlKGNoYWxsZW5nZVswXS5ib2R5KS5zZXNzaW9uLnNldHVwO1xuXG5cblx0JHNjb3BlLnN1Ym1pdENoYWxsZW5nZSA9IGZ1bmN0aW9uKCl7XG5cdFx0JHN0YXRlLmdvKCd0YWIuY2hhbGxlbmdlLXN1Ym1pdCcpO1xuXHRcdENoYWxsZW5nZUZhY3Rvcnkuc3VibWl0Q2hhbGxlbmdlKCkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cblx0XHRcdHJldHVybiByZXNwb25zZS5kYXRhO1xuXHRcdH0pLmNhdGNoKGZ1bmN0aW9uKGVycil7XG5cdFx0XHRjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KGVycikpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdCRzY29wZS50ZXN0Q2hhbGxlbmdlID0gZnVuY3Rpb24oKXtcblx0XHRDaGFsbGVuZ2VGYWN0b3J5LnRlc3RDaGFsbGVuZ2UoKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcblx0XHRcdHJldHVybiByZXNwb25zZS5kYXRhO1xuXHRcdH0pLmNhdGNoKGZ1bmN0aW9uKGVycil7XG5cdFx0XHRjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KGVycikpO1xuXHRcdH0pO1xuXHR9O1xuXG59KTtcblxuYXBwLmZhY3RvcnkoJ0NoYWxsZW5nZUZhY3RvcnknLCBmdW5jdGlvbigkaHR0cCwgQXBpRW5kcG9pbnQpe1xuXHRyZXR1cm4ge1xuXHRcdGdldENoYWxsZW5nZSA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KEFwaUVuZHBvaW50LnVybCArICcvY2hhbGxlbmdlJykudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5kYXRhO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRzdWJtaXRDaGFsbGVuZ2UgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuICRodHRwLnBvc3QoQXBpRW5kcG9pbnQudXJsICsgJy9jaGFsbGVuZ2Uvc3VibWl0JykudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5kYXRhO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHR0ZXN0Q2hhbGxlbmdlIDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiAkaHR0cC5wb3N0KEFwaUVuZHBvaW50LnVybCArICcvY2hhbGxlbmdlL3Rlc3QvJykudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5kYXRhO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufSk7IiwiIiwiYXBwLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgVVNFUl9ST0xFUyl7XG5cdCRzdGF0ZVByb3ZpZGVyLnN0YXRlKCd0YWIuY2hhbGxlbmdlLXN1Ym1pdCcsIHtcblx0XHR1cmwgOiAnL2NoYWxsZW5nZS9zdWJtaXQnLFxuXHRcdHZpZXdzOiB7XG5cdFx0XHQndGFiLWNoYWxsZW5nZScgOiB7XG5cdFx0XHRcdHRlbXBsYXRlVXJsIDogJ2ZlYXR1cmVzL2NoYWxsZW5nZS1zdWJtaXQvY2hhbGxlbmdlLXN1Ym1pdC5odG1sJyxcblx0XHRcdFx0Y29udHJvbGxlciA6ICdDaGFsbGVuZ2VTdWJtaXRDdHJsJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGF0YToge1xuXHRcdFx0YXV0aGVudGljYXRlOiBbVVNFUl9ST0xFUy5wdWJsaWNdXG5cdFx0fVxuXHR9KTtcbn0pO1xuXG5hcHAuY29udHJvbGxlcignQ2hhbGxlbmdlU3VibWl0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSl7XG5cblx0JHNjb3BlLmFjZUxvYWRlZCA9IGZ1bmN0aW9uKF9lZGl0b3Ipe1xuXHRcdGNvbnNvbGUubG9nKF9lZGl0b3IpO1xuXHR9O1xuXG5cdCRzY29wZS5hY2VDaGFuZ2VkID0gZnVuY3Rpb24oZSl7XG5cdFx0Y29uc29sZS5sb2coZSk7XG5cdH07XG5cblx0JHNjb3BlLnR4dCA9ICcnO1xuXG5cdCRzY29wZS5hY2VDb25maWcgPSB7XG5cdFx0dXNlV3JhcE1vZGUgOiB0cnVlLFxuXHRcdHNob3dHdXR0ZXIgOiB0cnVlLFxuXHRcdHRoZW1lOiAnbW9ub2thaScsXG5cdFx0bW9kZTogJ2phdmFzY3JpcHQnLFxuXHRcdG9uTG9hZDogJHNjb3BlLmFjZUxvYWRlZCxcblx0XHRvbkNoYW5nZSA6ICRzY29wZS5hY2VDaGFuZ2VkXG5cdH07XG5cdC8vdGV4dCBuZWVkcyB0byBiZSB3b3JrZWQgb25cblxuXHRjb25zb2xlLmxvZygndGhpcyBpcyBsb2FkZWQnKTtcbn0pOyIsIiIsImFwcC5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpe1xuXG4gICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCd0YWIuY2hhdHMnLCB7XG4gICAgICB1cmw6ICcvY2hhdHMnLFxuICAgICAgdmlld3M6IHtcbiAgICAgICAgJ3RhYi1jaGF0cyc6IHtcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2ZlYXR1cmVzL2NoYXRzL3RhYi1jaGF0cy5odG1sJyxcbiAgICAgICAgICBjb250cm9sbGVyOiAnQ2hhdHNDdHJsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICAuc3RhdGUoJ3RhYi5jaGF0LWRldGFpbCcsIHtcbiAgICAgIHVybDogJy9jaGF0cy86Y2hhdElkJyxcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgICd0YWItY2hhdHMnOiB7XG4gICAgICAgICAgdGVtcGxhdGVVcmw6ICdmZWF0dXJlcy9jaGF0cy9jaGF0LWRldGFpbC5odG1sJyxcbiAgICAgICAgICBjb250cm9sbGVyOiAnQ2hhdERldGFpbEN0cmwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5hcHAuY29udHJvbGxlcignQ2hhdHNDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCBDaGF0cykge1xuICAkc2NvcGUuY2hhdHMgPSBDaGF0cy5hbGwoKTtcbiAgJHNjb3BlLnJlbW92ZSA9IGZ1bmN0aW9uKGNoYXQpIHtcbiAgICBDaGF0cy5yZW1vdmUoY2hhdCk7XG4gIH07XG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ0NoYXREZXRhaWxDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsIENoYXRzKSB7XG4gICRzY29wZS5jaGF0ID0gQ2hhdHMuZ2V0KCRzdGF0ZVBhcmFtcy5jaGF0SWQpO1xufSk7XG5cbmFwcC5mYWN0b3J5KCdDaGF0cycsIGZ1bmN0aW9uKCkge1xuICAvLyBNaWdodCB1c2UgYSByZXNvdXJjZSBoZXJlIHRoYXQgcmV0dXJucyBhIEpTT04gYXJyYXlcblxuICAvLyBTb21lIGZha2UgdGVzdGluZyBkYXRhXG4gIHZhciBjaGF0cyA9IFt7XG4gICAgaWQ6IDAsXG4gICAgbmFtZTogJ0JlbiBTcGFycm93JyxcbiAgICBsYXN0VGV4dDogJ1lvdSBvbiB5b3VyIHdheT8nLFxuICAgIGZhY2U6ICdodHRwczovL3Bicy50d2ltZy5jb20vcHJvZmlsZV9pbWFnZXMvNTE0NTQ5ODExNzY1MjExMTM2LzlTZ0F1SGVZLnBuZydcbiAgfSwge1xuICAgIGlkOiAxLFxuICAgIG5hbWU6ICdNYXggTHlueCcsXG4gICAgbGFzdFRleHQ6ICdIZXksIGl0XFwncyBub3QgbWUnLFxuICAgIGZhY2U6ICdodHRwczovL2F2YXRhcnMzLmdpdGh1YnVzZXJjb250ZW50LmNvbS91LzExMjE0P3Y9MyZzPTQ2MCdcbiAgfSx7XG4gICAgaWQ6IDIsXG4gICAgbmFtZTogJ0FkYW0gQnJhZGxleXNvbicsXG4gICAgbGFzdFRleHQ6ICdJIHNob3VsZCBidXkgYSBib2F0JyxcbiAgICBmYWNlOiAnaHR0cHM6Ly9wYnMudHdpbWcuY29tL3Byb2ZpbGVfaW1hZ2VzLzQ3OTA5MDc5NDA1ODM3OTI2NC84NFRLal9xYS5qcGVnJ1xuICB9LCB7XG4gICAgaWQ6IDMsXG4gICAgbmFtZTogJ1BlcnJ5IEdvdmVybm9yJyxcbiAgICBsYXN0VGV4dDogJ0xvb2sgYXQgbXkgbXVrbHVrcyEnLFxuICAgIGZhY2U6ICdodHRwczovL3Bicy50d2ltZy5jb20vcHJvZmlsZV9pbWFnZXMvNDkxOTk1Mzk4MTM1NzY3MDQwL2llMlpfVjZlLmpwZWcnXG4gIH0sIHtcbiAgICBpZDogNCxcbiAgICBuYW1lOiAnTWlrZSBIYXJyaW5ndG9uJyxcbiAgICBsYXN0VGV4dDogJ1RoaXMgaXMgd2lja2VkIGdvb2QgaWNlIGNyZWFtLicsXG4gICAgZmFjZTogJ2h0dHBzOi8vcGJzLnR3aW1nLmNvbS9wcm9maWxlX2ltYWdlcy81NzgyMzcyODEzODQ4NDEyMTYvUjNhZTFuNjEucG5nJ1xuICB9XTtcblxuICByZXR1cm4ge1xuICAgIGFsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2hhdHM7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGNoYXQpIHtcbiAgICAgIGNoYXRzLnNwbGljZShjaGF0cy5pbmRleE9mKGNoYXQpLCAxKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oY2hhdElkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGF0c1tpXS5pZCA9PT0gcGFyc2VJbnQoY2hhdElkKSkge1xuICAgICAgICAgIHJldHVybiBjaGF0c1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufSk7XG4iLCJhcHAuY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKXtcblx0JHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2xvZ2luJywge1xuXHRcdHVybCA6ICcvbG9naW4nLFxuXHRcdHRlbXBsYXRlVXJsIDogJ2ZlYXR1cmVzL2xvZ2luL2xvZ2luLmh0bWwnLFxuXHRcdGNvbnRyb2xsZXIgOiAnTG9naW5DdHJsJ1xuXHR9KTtcbn0pO1xuXG5hcHAuY29udHJvbGxlcignTG9naW5DdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkaW9uaWNQb3B1cCwgJHN0YXRlLCBBdXRoU2VydmljZSl7XG5cdC8vJHNjb3BlLmFjY291bnQgPSBmdW5jdGlvbigpe1xuICAgIC8vXG5cdC8vfTtcblx0JHNjb3BlLmRhdGEgPSB7fTtcblx0JHNjb3BlLmVycm9yID0gbnVsbDtcblxuXHQkc2NvcGUubG9naW4gPSBmdW5jdGlvbigpe1xuXHRcdEF1dGhTZXJ2aWNlXG5cdFx0XHQubG9naW4oJHNjb3BlLmRhdGEpXG5cdFx0XHQudGhlbihmdW5jdGlvbihhdXRoZW50aWNhdGVkKXsgLy9UT0RPOmF1dGhlbnRpY2F0ZWQgaXMgd2hhdCBpcyByZXR1cm5lZFxuXHRcdFx0XHRjb25zb2xlLmxvZygnYXV0aGVudGljYXRlZCwgdGFiLmNoYWxsZW5nZS1zdWJtaXQnKTtcblx0XHRcdFx0JHN0YXRlLmdvKCd0YWIuY2hhbGxlbmdlLXN1Ym1pdCcpO1xuXHRcdFx0XHQvL1RPRE86IFdlIGNhbiBzZXQgdGhlIHVzZXIgbmFtZSBoZXJlIGFzIHdlbGwuIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIG1haW4gY3RybFxuXHRcdFx0fSlcblx0XHRcdC5jYXRjaChmdW5jdGlvbihlcnIpe1xuXHRcdFx0XHQkc2NvcGUuZXJyb3IgPSAnTG9naW4gSW52YWxpZCc7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyKSlcblx0XHRcdFx0dmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5hbGVydCh7XG5cdFx0XHRcdFx0dGl0bGU6ICdMb2dpbiBmYWlsZWQhJyxcblx0XHRcdFx0XHR0ZW1wbGF0ZTogJ1BsZWFzZSBjaGVjayB5b3VyIGNyZWRlbnRpYWxzISdcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHQvL0xvZ2luRmFjdG9yeVxuXHRcdC8vXHQucG9zdExvZ2luKCRzY29wZS5kYXRhKVxuXHRcdC8vXHQudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0Ly9cdFx0QXV0aFRva2VuRmFjdG9yeS5zZXRUb2tlbihyZXNwb25zZS5kYXRhLnRva2VuKTtcblx0XHQvL1x0XHQvL2NvbnNvbGUubG9nKCdnb3RvIHRhYi1jaGFsbGVuZ2Utc3VibWl0JyxyZXNwb25zZS5kYXRhLnRva2VuLCByZXNwb25zZS5kYXRhLnVzZXIpO1xuXHRcdC8vXHRcdCRzdGF0ZS5nbygndGFiLmNoYWxsZW5nZS1zdWJtaXQnKTtcblx0XHQvL1x0XHRyZXR1cm4gcmVzcG9uc2U7IC8vVE9ETzogcmVtb3ZlIGlmIG5vdCByZXF1aXJlZCwgeW91IGNhbiBqdXN0IGNoYW5nZSBzdGF0ZXMgaW5zdGVhZFxuXHRcdC8vXHR9KVxuXHRcdC8vXHQuY2F0Y2goZnVuY3Rpb24oZXJyKXtcblx0XHQvL1x0XHQkc2NvcGUuZXJyb3IgPSAnTG9naW4gSW52YWxpZCc7XG5cdFx0Ly9cdFx0Y29uc29sZS5lcnJvcihKU09OLnN0cmluZ2lmeShlcnIpKTtcblx0XHQvL1x0fSk7XG5cdH07XG59KTtcblxuLy9hcHAuZmFjdG9yeSgnTG9naW5GYWN0b3J5JyxmdW5jdGlvbigkaHR0cCxBcGlFbmRwb2ludCl7XG4vL1x0cmV0dXJue1xuLy9cdFx0cG9zdExvZ2luOiBmdW5jdGlvbih1c2VyZGF0YSl7XG4vL1x0XHRcdGNvbnNvbGUubG9nKCdwb3N0TG9naW4nLEpTT04uc3RyaW5naWZ5KHVzZXJkYXRhKSk7XG4vL1x0XHRcdHJldHVybiAkaHR0cC5wb3N0KEFwaUVuZHBvaW50LnVybCtcIi91c2VyL2xvZ2luXCIsIHVzZXJkYXRhKTtcbi8vXHRcdH1cbi8vXHR9O1xuLy99KTtcblxuLy9hcHAuY29udHJvbGxlcignTG9naW5DdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgQXV0aFNlcnZpY2UsICRzdGF0ZSkge1xuLy9cbi8vXHQkc2NvcGUubG9naW4gPSB7fTtcbi8vXHQkc2NvcGUuZXJyb3IgPSBudWxsO1xuLy9cbi8vXHQkc2NvcGUuc2VuZExvZ2luID0gZnVuY3Rpb24gKGxvZ2luSW5mbykge1xuLy9cbi8vXHRcdCRzY29wZS5lcnJvciA9IG51bGw7XG4vL1xuLy9cdFx0QXV0aFNlcnZpY2UubG9naW4obG9naW5JbmZvKS50aGVuKGZ1bmN0aW9uICgpIHtcbi8vXHRcdFx0JHN0YXRlLmdvKCdob21lJyk7XG4vL1x0XHR9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4vL1x0XHRcdCRzY29wZS5lcnJvciA9ICdJbnZhbGlkIGxvZ2luIGNyZWRlbnRpYWxzLic7XG4vL1x0XHR9KTtcbi8vXG4vL1x0fTtcbi8vXG4vL30pO1xuXG4iLCJhcHAuY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKXtcbiAgICAkc3RhdGVQcm92aWRlci5zdGF0ZSgnc2lnbnVwJyx7XG4gICAgICAgIHVybDpcIi9zaWdudXBcIixcbiAgICAgICAgdGVtcGxhdGVVcmw6IFwiZmVhdHVyZXMvc2lnbnVwL3NpZ251cC5odG1sXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdTaWduVXBDdHJsJ1xuICAgIH0pO1xufSk7XG5cbmFwcC5jb250cm9sbGVyKCdTaWduVXBDdHJsJyxmdW5jdGlvbigkaHR0cCwgJHNjb3BlLCAkc3RhdGUsIFNpZ25VcEZhY3RvcnksIEF1dGhTZXJ2aWNlKXtcbiAgICAkc2NvcGUuZGF0YSA9IHt9O1xuICAgICRzY29wZS5lcnJvciA9IG51bGw7XG5cbiAgICAkc2NvcGUuc2lnbnVwID0gZnVuY3Rpb24oKXtcbiAgICAgICAgU2lnblVwRmFjdG9yeSAvL1RPRE86IGNvbnZlcnQgdG8gdXNlIEF1dGggU2VydmljZSBpbnN0ZWFkXG4gICAgICAgICAgICAucG9zdFNpZ251cCgkc2NvcGUuZGF0YSlcbiAgICAgICAgICAgIC50aGVuKEF1dGhTZXJ2aWNlLnNpZ25lZFVwKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3RvIHRhYi1jaGFsbGVuZ2Utc3VibWl0JyxKU09OLnN0cmluZ2lmeShyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIC8vJGh0dHAuZ2V0KEFwaUVuZHBvaW50LnVybCtcIi9cIik7XG4gICAgICAgICAgICAgICAgLy9JTkZPOiBTZXNzaW9uIGlzIHN0b3JlZCBhcyBhIGNvb2tpZSBvbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vVE9ETzogQWRkIHJvdXRlIGRpc3BsYXkgc2Vzc2lvbiBkYXRhXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy9zdG9yZSBkYXRhIGluIHNlc3Npb25cbiAgICAgICAgICAgIC8vJHN0YXRlLmdvKCd0YWIuY2hhbGxlbmdlLXN1Ym1pdCcpOyAvL1RPRE86IEFkZCBSb3V0ZSBiYWNrLCByZW1vdmVkIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgICAgICRzY29wZS5lcnJvciA9ICdMb2dpbiBJbnZhbGlkJztcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbn0pO1xuXG4vL1RPRE86IE5FWFQgSG93IHRvIGNoZWNrIGZvciBzZXNzaW9uIGRhdGEgc3RvcmVkLCBvciBpZiBpdCBpcyBiZWluZyBzZW50IGJhY2ssIHNvbWVob3c/XG5cbmFwcC5mYWN0b3J5KCdTaWduVXBGYWN0b3J5JyxmdW5jdGlvbigkaHR0cCwgQXBpRW5kcG9pbnQpe1xuICAgIHJldHVybntcbiAgICAgICAgcG9zdFNpZ251cDogZnVuY3Rpb24odXNlcmRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3Bvc3RTaWdudXAnLEpTT04uc3RyaW5naWZ5KHVzZXJkYXRhKSk7XG4gICAgICAgICAgICByZXR1cm4gJGh0dHAucG9zdChBcGlFbmRwb2ludC51cmwrXCIvdXNlci9zaWdudXBcIiwgdXNlcmRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG4vL1RPRE86IEZvcm0gVmFsaWRhdGlvblxuXG4vL05FWFQ6IFNlbmRpbmcgZGF0YSB0byB0aGUgYmFjay1lbmQgYW5kIHNldHRpbmcgdXAgcm91dGVzXG4vL01vbmdvb3NlXG4iLCJhcHAuY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyKXtcblx0JHN0YXRlUHJvdmlkZXIuc3RhdGUoJ3dlbGNvbWUnLCB7XG5cdFx0dXJsIDogJy93ZWxjb21lJyxcblx0XHR0ZW1wbGF0ZVVybCA6ICdmZWF0dXJlcy93ZWxjb21lL3dlbGNvbWUuaHRtbCcsXG5cdFx0Y29udHJvbGxlciA6ICdXZWxjb21lQ3RybCdcblx0fSk7XG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ1dlbGNvbWVDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGUsIEF1dGhUb2tlbkZhY3Rvcnkpe1xuXHQvL1RPRE86IFNwbGFzaCBwYWdlIHdoaWxlIHlvdSBsb2FkIHJlc291cmNlcyAocG9zc2libGUgaWRlYSlcblx0JHNjb3BlLmxvZ2luID0gZnVuY3Rpb24oKXtcblx0XHQkc3RhdGUuZ28oJ2xvZ2luJyk7XG5cdH07XG5cdCRzY29wZS5zaWdudXAgPSBmdW5jdGlvbigpe1xuXHRcdCRzdGF0ZS5nbygnc2lnbnVwJyk7XG5cdH07XG5cblx0dmFyIHRva2VuID0gQXV0aFRva2VuRmFjdG9yeS5nZXRUb2tlbigpXG5cdGlmICh0b2tlbikge1xuXHRcdGNvbnNvbGUubG9nKHRva2VuKVxuXHRcdCRzdGF0ZS5nbygndGFiLmNoYWxsZW5nZS1zdWJtaXQnKTtcblx0fSBlbHNlIHtcblx0XHQkc3RhdGUuZ28oJ2xvZ2luJyk7XG5cdH1cblx0Ly99KTtcbn0pOyIsIi8vdG9rZW4gaXMgc2VudCBvbiBldmVyeSBodHRwIHJlcXVlc3RcbmFwcC5mYWN0b3J5KCdBdXRoSW50ZXJjZXB0b3InLGZ1bmN0aW9uIEF1dGhJbnRlcmNlcHRvcihBVVRIX0VWRU5UUywkcm9vdFNjb3BlLCRxLEF1dGhUb2tlbkZhY3Rvcnkpe1xuXG4gICAgdmFyIHN0YXR1c0RpY3QgPSB7XG4gICAgICAgIDQwMTogQVVUSF9FVkVOVFMubm90QXV0aGVudGljYXRlZCxcbiAgICAgICAgNDAzOiBBVVRIX0VWRU5UUy5ub3RBdXRob3JpemVkXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IGFkZFRva2VuLFxuICAgICAgICByZXNwb25zZUVycm9yOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChzdGF0dXNEaWN0W3Jlc3BvbnNlLnN0YXR1c10sIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFkZFRva2VuKGNvbmZpZyl7XG4gICAgICAgIHZhciB0b2tlbiA9IEF1dGhUb2tlbkZhY3RvcnkuZ2V0VG9rZW4oKTtcbiAgICAgICAgaWYodG9rZW4pe1xuICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmVhcmVyICcgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbn0pOyAvL3NraXBwZWQgQXV0aCBJbnRlcmNlcHRvcnMgZ2l2ZW4gVE9ETzogWW91IGNvdWxkIGFwcGx5IHRoZSBhcHByb2FjaCBpblxuLy9odHRwOi8vZGV2ZGFjdGljLmNvbS91c2VyLWF1dGgtYW5ndWxhcmpzLWlvbmljL1xuXG5hcHAuY29uZmlnKGZ1bmN0aW9uKCRodHRwUHJvdmlkZXIpe1xuICAgICRodHRwUHJvdmlkZXIuaW50ZXJjZXB0b3JzLnB1c2goJ0F1dGhJbnRlcmNlcHRvcicpO1xufSk7XG5cbmFwcC5jb25zdGFudCgnQVVUSF9FVkVOVFMnLCB7XG4gICAgICAgIG5vdEF1dGhlbnRpY2F0ZWQ6ICdhdXRoLW5vdC1hdXRoZW50aWNhdGVkJyxcbiAgICAgICAgbm90QXV0aG9yaXplZDogJ2F1dGgtbm90LWF1dGhvcml6ZWQnXG59KTtcblxuYXBwLmNvbnN0YW50KCdVU0VSX1JPTEVTJywge1xuICAgICAgICAvL2FkbWluOiAnYWRtaW5fcm9sZScsXG4gICAgICAgIHB1YmxpYzogJ3B1YmxpY19yb2xlJ1xufSk7XG5cbmFwcC5mYWN0b3J5KCdBdXRoVG9rZW5GYWN0b3J5JyxmdW5jdGlvbigkd2luZG93KXtcbiAgICB2YXIgc3RvcmUgPSAkd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICB2YXIga2V5ID0gJ2F1dGgtdG9rZW4nO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0VG9rZW46IGdldFRva2VuLFxuICAgICAgICBzZXRUb2tlbjogc2V0VG9rZW5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0VG9rZW4oKXtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldEl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICAvL1RPRE86IENyZWF0ZSBsb2ctb3V0IGZ1bmN0aW9uLCB3ZXJlIGlmIHRva2VuIGlzIG5vdCBkZWZpbmVkLCByZW1vdmUgdG9rZW5cbiAgICBmdW5jdGlvbiBzZXRUb2tlbih0b2tlbil7XG4gICAgICAgIGlmKHRva2VuKXtcbiAgICAgICAgICAgIHN0b3JlLnNldEl0ZW0oa2V5LHRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5hcHAuc2VydmljZSgnQXV0aFNlcnZpY2UnLGZ1bmN0aW9uKCRxLCRodHRwLFVTRVJfUk9MRVMsQXV0aFRva2VuRmFjdG9yeSxBcGlFbmRwb2ludCwkcm9vdFNjb3BlKXtcbiAgICAvL3ZhciBMT0NBTF9UT0tFTl9LRVkgPSAnYXV0aC10b2tlbic7XG4gICAgdmFyIHVzZXJuYW1lID0gJyc7XG4gICAgdmFyIGlzQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgIHZhciBhdXRoVG9rZW47XG5cblxuICAgIGZ1bmN0aW9uIGxvYWRVc2VyQ3JlZGVudGlhbHMoKSB7XG4gICAgICAgIC8vdmFyIHRva2VuID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKExPQ0FMX1RPS0VOX0tFWSk7XG4gICAgICAgIHZhciB0b2tlbiA9IEF1dGhUb2tlbkZhY3RvcnkuZ2V0VG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB1c2VDcmVkZW50aWFscyh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9yZVVzZXJDcmVkZW50aWFscyh0b2tlbikge1xuICAgICAgICBBdXRoVG9rZW5GYWN0b3J5LnNldFRva2VuKHRva2VuKTtcbiAgICAgICAgdXNlQ3JlZGVudGlhbHModG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVzZUNyZWRlbnRpYWxzKHRva2VuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd1c2VDcmVkZW50aWFscyB0b2tlbicsdG9rZW4pO1xuICAgICAgICB1c2VybmFtZSA9IHRva2VuLnVzZXI7IC8vVE9ETzogY2hlY2sgdGhpc1xuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgICAgICBhdXRoVG9rZW4gPSB0b2tlbi50b2tlbjsgLy9UT0RPOiBjaGVjayB0aGlzXG5cbiAgICAgICAgLy8gU2V0IHRoZSB0b2tlbiBhcyBoZWFkZXIgZm9yIHlvdXIgcmVxdWVzdHMhXG4gICAgICAgIC8vJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtQXV0aC1Ub2tlbiddID0gdG9rZW47IC8vVE9ET1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3lVc2VyQ3JlZGVudGlhbHMoKSB7XG4gICAgICAgIGF1dGhUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdXNlcm5hbWUgPSAnJztcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIC8vJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtQXV0aC1Ub2tlbiddID0gdW5kZWZpbmVkO1xuICAgICAgICAvL3dpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0NBTF9UT0tFTl9LRVkpO1xuICAgICAgICBBdXRoVG9rZW5GYWN0b3J5LnNldFRva2VuKCk7IC8vZW1wdHkgY2xlYXJzIHRoZSB0b2tlblxuICAgIH1cblxuICAgIHZhciBsb2dvdXQgPSBmdW5jdGlvbigpe1xuICAgICAgICBkZXN0cm95VXNlckNyZWRlbnRpYWxzKCk7XG4gICAgfTtcblxuICAgIC8vdmFyIGxvZ2luID0gZnVuY3Rpb24oKVxuICAgIHZhciBsb2dpbiA9IGZ1bmN0aW9uKHVzZXJkYXRhKXtcbiAgICAgICAgY29uc29sZS5sb2coJ3Bvc3RMb2dpbicsSlNPTi5zdHJpbmdpZnkodXNlcmRhdGEpKTtcbiAgICAgICAgcmV0dXJuICRxKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgICAgICRodHRwLnBvc3QoQXBpRW5kcG9pbnQudXJsK1wiL3VzZXIvbG9naW5cIiwgdXNlcmRhdGEpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAgICAgICAgICAgICBBdXRoVG9rZW5GYWN0b3J5LnNldFRva2VuKHJlc3BvbnNlLmRhdGEudG9rZW4pOyAvL3N0b3JlVXNlckNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpOyAvL1RPRE86IHNlbnQgdG8gYXV0aGVudGljYXRlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgbG9hZFVzZXJDcmVkZW50aWFscygpO1xuXG4gICAgdmFyIGlzQXV0aG9yaXplZCA9IGZ1bmN0aW9uKGF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzQXJyYXkoYXV0aGVudGljYXRlZCkpIHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWQgPSBbYXV0aGVudGljYXRlZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpc0F1dGhlbnRpY2F0ZWQgJiYgYXV0aGVudGljYXRlZC5pbmRleE9mKFVTRVJfUk9MRVMucHVibGljKSAhPT0gLTEpO1xuICAgIH07XG4gICAgXG4gICAgLy9UT0RPOiBOZWVkIHRvIGZpeCBnZXRMb2dnZWRJblVzZXJcbiAgICAvL3ZhciBnZXRMb2dnZWRJblVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gICAgY29uc29sZS5sb2coJ2dldExvZ2dlZEluVXNlciBjYWxsZWQnKVxuICAgIC8vICAgIC8vIElmIGFuIGF1dGhlbnRpY2F0ZWQgc2Vzc2lvbiBleGlzdHMsIHdlXG4gICAgLy8gICAgLy8gcmV0dXJuIHRoZSB1c2VyIGF0dGFjaGVkIHRvIHRoYXQgc2Vzc2lvblxuICAgIC8vICAgIC8vIHdpdGggYSBwcm9taXNlLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBjYW5cbiAgICAvLyAgICAvLyBhbHdheXMgaW50ZXJmYWNlIHdpdGggdGhpcyBtZXRob2QgYXN5bmNocm9ub3VzbHkuXG4gICAgLy9cbiAgICAvLyAgICAvL1RPRE86IEluIHdoYXQgY2FzZSB3aWxsIHRoZSBiZWxvdyBjb2RlIHJ1bj8gSXQgd2lsbCB3b3JrLCBidXQgbm90IGNsZWFyIG9mIHRoZSB1c2VcbiAgICAvLyAgICBpZiAoaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgLy8gICAgICAgIHJldHVybiAkcS53aGVuKEF1dGhUb2tlbkZhY3RvcnkuZ2V0VG9rZW4oKSk7XG4gICAgLy8gICAgfVxuICAgIC8vXG4gICAgLy8gICAgLy8gTWFrZSByZXF1ZXN0IEdFVCAvc2Vzc2lvbi5cbiAgICAvLyAgICAvLyBJZiBpdCByZXR1cm5zIGEgdXNlciwgY2FsbCBvblN1Y2Nlc3NmdWxMb2dpbiB3aXRoIHRoZSByZXNwb25zZS5cbiAgICAvLyAgICAvLyBJZiBpdCByZXR1cm5zIGEgNDAxIHJlc3BvbnNlLCB3ZSBjYXRjaCBpdCBhbmQgaW5zdGVhZCByZXNvbHZlIHRvIG51bGwuXG4gICAgLy9cbiAgICAvLyAgICAvL2lmKEF1dGhUb2tlbkZhY3RvcnkuZ2V0VG9rZW4oKSl7XG4gICAgLy8gICAgLy8gICAgcmV0dXJuICRodHRwLmdldChBcGlFbmRwb2ludC51cmwrJy91c2VyL3Rva2VuJylcbiAgICAvLyAgICAvLyAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgIC8vICAgIC8vICAgICAgICAgICAgY29uc29sZS5sb2coJ0FwaUVuZHBvaW50LnVybCAvdXNlci90b2tlbiByZXNwb25zZScscmVzcG9uc2UpO1xuICAgIC8vICAgIC8vICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhLnVzZXJcbiAgICAvLyAgICAvLyAgICAgICAgICAgIC8vVE9ETzokcm9vdFNjb3BlLiRicm9hZGNhc3QoQVVUSF9FVkVOVFMubG9naW5TdWNjZXNzKTtcbiAgICAvLyAgICAvLyAgICAgICAgICAgIHJldHVybiBkYXRhOyAvL3VzZXIgaXMgYmVpbmcgcmV0dXJuZWRcbiAgICAvLyAgICAvLyAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgIC8vICAgIC8vICAgICAgICAgICAgY29uc29sZS5sb2coJ2dldExvZ2dlZEluVXNlciByZXR1cm5lZCBudWxsJyk7XG4gICAgLy8gICAgLy8gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyAgICAvLyAgICAgICAgfSk7XG4gICAgLy8gICAgLy99IGVsc2Uge1xuICAgIC8vICAgIC8vICAgIHJldHVybiAkcS5yZWplY3Qoe2RhdGE6ICdubyBhdXRoIHRva2VuIGV4aXN0cyd9KTtcbiAgICAvLyAgICAvL31cbiAgICAvLyAgICByZXR1cm4gJGh0dHAuZ2V0KEFwaUVuZHBvaW50LnVybCArICcvdXNlci90b2tlbicpXG4gICAgLy8gICAgICAgIC50aGVuKG9uU3VjY2Vzc2Z1bExvZ2luKVxuICAgIC8vICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pO1xuICAgIC8vfTtcbiAgICAvL1xuICAgIC8vZnVuY3Rpb24gb25TdWNjZXNzZnVsTG9naW4ocmVzcG9uc2UpIHtcbiAgICAvLyAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgLy8gICAgY29uc29sZS5sb2cocmVzcG9uc2UuZGF0YSk7XG4gICAgLy8gICAgLy9TZXNzaW9uLmNyZWF0ZShkYXRhLmlkLCBkYXRhLnVzZXIpO1xuICAgIC8vICAgIEF1dGhUb2tlbkZhY3Rvcnkuc2V0VG9rZW4ocmVzcG9uc2UuZGF0YS50b2tlbilcbiAgICAvLyAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdChBVVRIX0VWRU5UUy5sb2dpblN1Y2Nlc3MpO1xuICAgIC8vICAgIHJldHVybiBkYXRhLnVzZXI7XG4gICAgLy99XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsb2dpbjogbG9naW4sXG4gICAgICAgIGxvZ291dDogbG9nb3V0LFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpJyk7XG4gICAgICAgICAgICByZXR1cm4gaXNBdXRoZW50aWNhdGVkO1xuICAgICAgICB9LFxuICAgICAgICB1c2VybmFtZTogZnVuY3Rpb24oKXtyZXR1cm4gdXNlcm5hbWU7fSxcbiAgICAgICAgLy9nZXRMb2dnZWRJblVzZXI6IGdldExvZ2dlZEluVXNlcixcbiAgICAgICAgaXNBdXRob3JpemVkOiBpc0F1dGhvcml6ZWRcbiAgICB9XG5cbn0pO1xuXG4vL1RPRE86IERpZCBub3QgY29tcGxldGUgbWFpbiBjdHJsICdBcHBDdHJsIGZvciBoYW5kbGluZyBldmVudHMnIGFzIHBlciBodHRwOi8vZGV2ZGFjdGljLmNvbS91c2VyLWF1dGgtYW5ndWxhcmpzLWlvbmljLyIsImFwcC5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIpe1xuXG4gIFx0Ly8gc2V0dXAgYW4gYWJzdHJhY3Qgc3RhdGUgZm9yIHRoZSB0YWJzIGRpcmVjdGl2ZVxuICAgICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCd0YWInLCB7XG5cdCAgICB1cmw6IFwiL3RhYlwiLFxuXHQgICAgYWJzdHJhY3Q6IHRydWUsXG5cdCAgICB0ZW1wbGF0ZVVybDogXCJmZWF0dXJlcy9jb21tb24vdGFicy90YWJzLmh0bWxcIlxuXHR9KTtcbn0pOyJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==